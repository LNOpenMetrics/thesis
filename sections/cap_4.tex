\chapter{Technology Used}

\section{Go Programming Language}

We choose the Go Programming Language to be able to use the concurrency model
build in the language to be able to scale the architecture in the future and to prepare
it for real usage. In fact, the Go language implement a concurrency model direcly in 
the language with the \emph{go routine}.
In addition, with the go module was easy share code between implement as we need it, 
withoud spend much time about the design of a general solution, and this choice
give us the possibility to implement the analysis feature described in \ref{sec:lnmetrics_server}
by importing one module from the analysis system inside the plugin described \ref{sec:lnmetrics_client}.

\section{Core Lightning Plugin API}

Prototyping the implementation of the lnmetrics on a real lightning implementation was the 
most difficult part, because the implementation are really different between each others, and 
them have different API. In our solution we choose to use the core lightning plugin API, that 
allow anyone to extend the API core lightning with a plugin that can be written in any language. 
So, the plugin API allow to register a new \emph{JSON RPC 2.0}\cite{jsonrpc20} method, and 
also listen to events generated by the node through JSON RPC 2.0 notification.

\subsection{cln4go core lightning API library}

In order to interact with the core lightning node we choose to implement a go 
API for core lightning available on Github \url{https://github.com/vincenzopalazzo/cln4go}, 
because the current library available was not updated with the current version of 
the core lightning API, and also the library was written with an old Go language 
that did not support generics. The generics feature implemented in Go language 
1.18 allow to write strongly typed library and define the type inside the 
user module and not inside the library. In this way, it is possible supports all the 
core lightning versions, and leave the choice to the user regarding what kind of version supports
at application level. 

One of the reason for developing an API library with this design is that 
the core lightning API is evolving fast, and sometime the node are not using the 
recent version of the node, but users are one or two version bheaind, so with our solution 
the author of the plugin is free to enforce any rules regarding the core lightning version 
and it is not contraint by the developer of the core lightning plugin API.

In addition, the library allow to specify at runtime the JSON encoder to use 
inside the library, and this allow to use more performant library like \emph{go-json}\cite{gojson}, 
where this feature is important to remove some pain point of the Go language such 
as the reflection used during the encoding and decoding of the JSON from and to a Go struct.
A performance measurement with the well known glightning library \cite{glightning} 
for core lightning library is shows in the Figure (add figure).

\section{lnmetrics.utils}

Implementing all the architecture in Go Language required implementing shared code 
that it is used in all the projects developed such as the the database code or the 
logger. In order to provide all this shared code in a single place and also implements 
missing feature around the golang ecosystem such as a powerfull time library that allow 
to perform operation on the unix timestamp we develop a library called lnmetrics.utils that
implement all the code that we share across the projects. 
The library is available on Github at \url{https://github.com/LNOpenMetrics/lnmetrics.utils}.

\section{GraphQL and GQLGen}

\subsection{GraphQL Protocol}

In order to implement an analysis system with public API described in \ref{sec:lnmetrics_server}
we choose to use the GraphQL protocol \cite{graphql} that implement  a query language and runtime for APIs 
developed by Facebook in 2012 and released as an open-source project in 2015. 
It is designed to enable clients to specify exactly what data they need from an API, 
and nothing more. This is achieved through a typed schema that describes the data 
available in the API, and a set of queries that clients can use to request the 
specific data they need.
Unlike REST APIs, which often require multiple requests to fetch related data, 
GraphQL allows clients to retrieve all the necessary data in a single request. 
This makes it particularly useful for mobile and web applications, where minimizing 
the number of network requests can improve performance.

\subsection{GQLGen Library}

In order to implement the GraphQL protocol \cite{graphql} in the analysis system we used the library
gqlgen \cite{gqlgen} that is a Go library for building GraphQL servers that follows the GraphQL specification. 
It generates Go code from a GraphQL schema and a set of resolver functions, which are written 
by the developer to handle the queries and mutations defined in the schema. The generated code 
provides a strongly typed API that can be used to interact with the GraphQL server.

One of the benefits of using gqlgen is that it allows for a clear separation of 
concerns between the schema definition and the resolver implementation. This makes it 
easier to maintain and evolve the schema over time, without having to modify the resolver code.

\section{JSON Schema}

In order to define a description of the data model described in \ref{sec:data_definition}
we use the JSON Schema. It is a vocabulary that allows for the definition of JSON data structure. 
It provides a way to describe the expected format and structure of JSON data, and 
can be used to validate that JSON data conforms to a specific schema.
JSON Schema is particularly useful for defining APIs that exchange data in JSON 
format, by defining a JSON Schema for the data, clients can know exactly what data 
they can expect to receive from the API and how it should be structured.
A JSON Schema is defined using JSON itself, and consists of a set of keywords 
that describe the expected format and structure of the data. These keywords 
include things like type, properties, required, and pattern, among others.
Overall, JSON Schema provides a powerful and flexible way to define the structure of 
JSON data, and is an important tool for building APIs that exchange data in JSON format.
